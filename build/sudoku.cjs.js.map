{"version":3,"file":"sudoku.cjs.js","sources":["../lib/sudoku.js","../lib/index.cjs.js"],"sourcesContent":["/*\r\n    Sudoku.js\r\n    ---------\r\n    A Sudoku puzzle generator and solver JavaScript library.\r\n    Please see the README for more details.\r\n*/\r\n\r\nconst sudoku = {} // Global reference to the sudoku library\r\n\r\nsudoku.DIGITS = '123456789' // Allowed sudoku.DIGITS\r\nconst ROWS = 'ABCDEFGHI' // Row lables\r\nconst COLS = sudoku.DIGITS // Column lables\r\nlet SQUARES = null // Square IDs\r\n\r\nlet UNITS = null // All units (row, column, or box)\r\nlet SQUARE_UNITS_MAP = null // Squares -> units map\r\nlet SQUARE_PEERS_MAP = null // Squares -> peers map\r\n\r\nconst MIN_GIVENS = 17 // Minimum number of givens\r\nconst NR_SQUARES = 81 // Number of squares\r\n\r\n// Define difficulties by how many squares are given to the player in a new\r\n// puzzle.\r\nconst DIFFICULTY = {\r\n  easy: 62,\r\n  medium: 53,\r\n  hard: 44,\r\n  'very-hard': 35,\r\n  insane: 26,\r\n  inhuman: 17,\r\n}\r\n\r\n// Blank character and board representation\r\nsudoku.BLANK_CHAR = '.'\r\nsudoku.BLANK_BOARD = '....................................................' + '.............................'\r\n\r\n// Init\r\n// -------------------------------------------------------------------------\r\nfunction initialize() {\r\n  /* Initialize the Sudoku library (invoked after library load)\r\n   */\r\n  SQUARES = sudoku._cross(ROWS, COLS)\r\n  UNITS = sudoku._get_all_units(ROWS, COLS)\r\n  SQUARE_UNITS_MAP = sudoku._get_square_units_map(SQUARES, UNITS)\r\n  SQUARE_PEERS_MAP = sudoku._get_square_peers_map(SQUARES, SQUARE_UNITS_MAP)\r\n}\r\n\r\n// Generate\r\n// -------------------------------------------------------------------------\r\nsudoku.generate = function (difficulty, unique) {\r\n  /* Generate a new Sudoku puzzle of a particular `difficulty`, e.g.,\r\n      \r\n          // Generate an \"easy\" sudoku puzzle\r\n          sudoku.generate(\"easy\");\r\n          \r\n      \r\n      Difficulties are as follows, and represent the number of given squares:\r\n      \r\n              \"easy\":         61\r\n              \"medium\":       52\r\n              \"hard\":         43\r\n              \"very-hard\":    34\r\n              \"insane\":       25\r\n              \"inhuman\":      17\r\n          \r\n          \r\n      You may also enter a custom number of squares to be given, e.g.,\r\n      \r\n          // Generate a new Sudoku puzzle with 60 given squares\r\n          sudoku.generate(60)\r\n  \r\n  \r\n      `difficulty` must be a number between 17 and 81 inclusive. If it's\r\n      outside of that range, `difficulty` will be set to the closest bound,\r\n      e.g., 0 -> 17, and 100 -> 81.\r\n      \r\n      \r\n      By default, the puzzles are unique, uless you set `unique` to false. \r\n      (Note: Puzzle uniqueness is not yet implemented, so puzzles are *not* \r\n      guaranteed to have unique solutions)\r\n      \r\n      TODO: Implement puzzle uniqueness\r\n      */\r\n\r\n  // If `difficulty` is a string or undefined, convert it to a number or\r\n  // default it to \"easy\" if undefined.\r\n  if (typeof difficulty === 'string' || typeof difficulty === 'undefined') {\r\n    difficulty = DIFFICULTY[difficulty] || DIFFICULTY.easy\r\n  }\r\n\r\n  // Force difficulty between 17 and 81 inclusive\r\n  difficulty = sudoku._force_range(difficulty, NR_SQUARES + 1, MIN_GIVENS)\r\n\r\n  // Default unique to true\r\n  unique = unique || true\r\n\r\n  // Get a set of squares and all possible candidates for each square\r\n  let blank_board = ''\r\n  for (let i = 0; i < NR_SQUARES; ++i) {\r\n    blank_board += '.'\r\n  }\r\n  const candidates = sudoku._get_candidates_map(blank_board)\r\n\r\n  // For each item in a shuffled list of squares\r\n  const shuffled_squares = sudoku._shuffle(SQUARES)\r\n  for (let si in shuffled_squares) {\r\n    let square = shuffled_squares[si]\r\n\r\n    // If an assignment of a random chioce causes a contradictoin, give\r\n    // up and try again\r\n    let rand_candidate_idx = sudoku._rand_range(candidates[square].length)\r\n    let rand_candidate = candidates[square][rand_candidate_idx]\r\n    if (!sudoku._assign(candidates, square, rand_candidate)) {\r\n      break\r\n    }\r\n\r\n    // Make a list of all single candidates\r\n    let single_candidates = []\r\n    for (let si in SQUARES) {\r\n      let square = SQUARES[si]\r\n\r\n      if (candidates[square].length == 1) {\r\n        single_candidates.push(candidates[square])\r\n      }\r\n    }\r\n\r\n    // If we have at least difficulty, and the unique candidate count is\r\n    // at least 8, return the puzzle!\r\n    if (single_candidates.length >= difficulty && sudoku._strip_dups(single_candidates).length >= 8) {\r\n      let board = ''\r\n      let givens_idxs = []\r\n      for (let i in SQUARES) {\r\n        let square = SQUARES[i]\r\n        if (candidates[square].length == 1) {\r\n          board += candidates[square]\r\n          givens_idxs.push(i)\r\n        } else {\r\n          board += sudoku.BLANK_CHAR\r\n        }\r\n      }\r\n\r\n      // If we have more than `difficulty` givens, remove some random\r\n      // givens until we're down to exactly `difficulty`\r\n      let nr_givens = givens_idxs.length\r\n      if (nr_givens > difficulty) {\r\n        givens_idxs = sudoku._shuffle(givens_idxs)\r\n        for (let i = 0; i < nr_givens - difficulty; ++i) {\r\n          let target = parseInt(givens_idxs[i])\r\n          board = board.substr(0, target) + sudoku.BLANK_CHAR + board.substr(target + 1)\r\n        }\r\n      }\r\n\r\n      // Double check board is solvable\r\n      // TODO: Make a standalone board checker. Solve is expensive.\r\n      if (sudoku.solve(board)) {\r\n        return board\r\n      }\r\n    }\r\n  }\r\n\r\n  // Give up and try a new puzzle\r\n  return sudoku.generate(difficulty)\r\n}\r\n\r\n// Solve\r\n// -------------------------------------------------------------------------\r\nsudoku.solve = function (board, reverse) {\r\n  /* Solve a sudoku puzzle given a sudoku `board`, i.e., an 81-character \r\n      string of sudoku.DIGITS, 1-9, and spaces identified by '.', representing the\r\n      squares. There must be a minimum of 17 givens. If the given board has no\r\n      solutions, return false.\r\n      \r\n      Optionally set `reverse` to solve \"backwards\", i.e., rotate through the\r\n      possibilities in reverse. Useful for checking if there is more than one\r\n      solution.\r\n      */\r\n\r\n  // Assure a valid board\r\n  let report = sudoku.validate_board(board)\r\n  if (report !== true) {\r\n    throw report\r\n  }\r\n\r\n  // Check number of givens is at least MIN_GIVENS\r\n  let nr_givens = 0\r\n  for (let i in board) {\r\n    if (board[i] !== sudoku.BLANK_CHAR && sudoku._in(board[i], sudoku.DIGITS)) {\r\n      ++nr_givens\r\n    }\r\n  }\r\n  if (nr_givens < MIN_GIVENS) {\r\n    throw 'Too few givens. Minimum givens is ' + MIN_GIVENS\r\n  }\r\n\r\n  // Default reverse to false\r\n  reverse = reverse || false\r\n\r\n  let candidates = sudoku._get_candidates_map(board)\r\n  let result = sudoku._search(candidates, reverse)\r\n\r\n  if (result) {\r\n    let solution = ''\r\n    for (let square in result) {\r\n      solution += result[square]\r\n    }\r\n    return solution\r\n  }\r\n  return false\r\n}\r\n\r\nsudoku.get_candidates = function (board) {\r\n  /* Return all possible candidatees for each square as a grid of \r\n      candidates, returnning `false` if a contradiction is encountered.\r\n      \r\n      Really just a wrapper for sudoku._get_candidates_map for programmer\r\n      consumption.\r\n      */\r\n\r\n  // Assure a valid board\r\n  let report = sudoku.validate_board(board)\r\n  if (report !== true) {\r\n    throw report\r\n  }\r\n\r\n  // Get a candidates map\r\n  let candidates_map = sudoku._get_candidates_map(board)\r\n\r\n  // If there's an error, return false\r\n  if (!candidates_map) {\r\n    return false\r\n  }\r\n\r\n  // Transform candidates map into grid\r\n  let rows = []\r\n  let cur_row = []\r\n  let i = 0\r\n  for (let square in candidates_map) {\r\n    let candidates = candidates_map[square]\r\n    cur_row.push(candidates)\r\n    if (i % 9 == 8) {\r\n      rows.push(cur_row)\r\n      cur_row = []\r\n    }\r\n    ++i\r\n  }\r\n  return rows\r\n}\r\n\r\nsudoku._get_candidates_map = function (board) {\r\n  /* Get all possible candidates for each square as a map in the form\r\n      {square: sudoku.DIGITS} using recursive constraint propagation. Return `false` \r\n      if a contradiction is encountered\r\n      */\r\n\r\n  // Assure a valid board\r\n  let report = sudoku.validate_board(board)\r\n  if (report !== true) {\r\n    throw report\r\n  }\r\n\r\n  let candidate_map = {}\r\n  let squares_values_map = sudoku._get_square_vals_map(board)\r\n\r\n  // Start by assigning every digit as a candidate to every square\r\n  for (let si in SQUARES) {\r\n    candidate_map[SQUARES[si]] = sudoku.DIGITS\r\n  }\r\n\r\n  // For each non-blank square, assign its value in the candidate map and\r\n  // propigate.\r\n  for (let square in squares_values_map) {\r\n    let val = squares_values_map[square]\r\n\r\n    if (sudoku._in(val, sudoku.DIGITS)) {\r\n      let new_candidates = sudoku._assign(candidate_map, square, val)\r\n\r\n      // Fail if we can't assign val to square\r\n      if (!new_candidates) {\r\n        return false\r\n      }\r\n    }\r\n  }\r\n\r\n  return candidate_map\r\n}\r\n\r\nsudoku._search = function (candidates, reverse) {\r\n  /* Given a map of squares -> candiates, using depth-first search, \r\n      recursively try all possible values until a solution is found, or false\r\n      if no solution exists. \r\n      */\r\n\r\n  // Return if error in previous iteration\r\n  if (!candidates) {\r\n    return false\r\n  }\r\n\r\n  // Default reverse to false\r\n  reverse = reverse || false\r\n\r\n  // If only one candidate for every square, we've a solved puzzle!\r\n  // Return the candidates map.\r\n  let max_nr_candidates = 0\r\n  let max_candidates_square = null\r\n  for (let si in SQUARES) {\r\n    let square = SQUARES[si]\r\n\r\n    let nr_candidates = candidates[square].length\r\n\r\n    if (nr_candidates > max_nr_candidates) {\r\n      max_nr_candidates = nr_candidates\r\n      max_candidates_square = square\r\n    }\r\n  }\r\n  if (max_nr_candidates === 1) {\r\n    return candidates\r\n  }\r\n\r\n  // Choose the blank square with the fewest possibilities > 1\r\n  let min_nr_candidates = 10\r\n  let min_candidates_square = null\r\n  for (let si in SQUARES) {\r\n    let square = SQUARES[si]\r\n\r\n    let nr_candidates = candidates[square].length\r\n\r\n    if (nr_candidates < min_nr_candidates && nr_candidates > 1) {\r\n      min_nr_candidates = nr_candidates\r\n      min_candidates_square = square\r\n    }\r\n  }\r\n\r\n  // Recursively search through each of the candidates of the square\r\n  // starting with the one with fewest candidates.\r\n\r\n  // Rotate through the candidates forwards\r\n  let min_candidates = candidates[min_candidates_square]\r\n  if (!reverse) {\r\n    for (let vi in min_candidates) {\r\n      let val = min_candidates[vi]\r\n\r\n      // TODO: Implement a non-rediculous deep copy function\r\n      let candidates_copy = JSON.parse(JSON.stringify(candidates))\r\n      let candidates_next = sudoku._search(sudoku._assign(candidates_copy, min_candidates_square, val))\r\n\r\n      if (candidates_next) {\r\n        return candidates_next\r\n      }\r\n    }\r\n\r\n    // Rotate through the candidates backwards\r\n  } else {\r\n    for (let vi = min_candidates.length - 1; vi >= 0; --vi) {\r\n      let val = min_candidates[vi]\r\n\r\n      // TODO: Implement a non-rediculous deep copy function\r\n      let candidates_copy = JSON.parse(JSON.stringify(candidates))\r\n      let candidates_next = sudoku._search(sudoku._assign(candidates_copy, min_candidates_square, val), reverse)\r\n\r\n      if (candidates_next) {\r\n        return candidates_next\r\n      }\r\n    }\r\n  }\r\n\r\n  // If we get through all combinations of the square with the fewest\r\n  // candidates without finding an answer, there isn't one. Return false.\r\n  return false\r\n}\r\n\r\nsudoku._assign = function (candidates, square, val) {\r\n  /* Eliminate all values, *except* for `val`, from `candidates` at \r\n      `square` (candidates[square]), and propagate. Return the candidates map\r\n      when finished. If a contradiciton is found, return false.\r\n      \r\n      WARNING: This will modify the contents of `candidates` directly.\r\n      */\r\n\r\n  // Grab a list of canidates without 'val'\r\n  let other_vals = candidates[square].replace(val, '')\r\n\r\n  // Loop through all other values and eliminate them from the candidates\r\n  // at the current square, and propigate. If at any point we get a\r\n  // contradiction, return false.\r\n  for (let ovi in other_vals) {\r\n    let other_val = other_vals[ovi]\r\n\r\n    let candidates_next = sudoku._eliminate(candidates, square, other_val)\r\n\r\n    if (!candidates_next) {\r\n      //console.log(\"Contradiction found by _eliminate.\");\r\n      return false\r\n    }\r\n  }\r\n\r\n  return candidates\r\n}\r\n\r\nsudoku._eliminate = function (candidates, square, val) {\r\n  /* Eliminate `val` from `candidates` at `square`, (candidates[square]),\r\n      and propagate when values or places <= 2. Return updated candidates,\r\n      unless a contradiction is detected, in which case, return false.\r\n      \r\n      WARNING: This will modify the contents of `candidates` directly.\r\n      */\r\n\r\n  // If `val` has already been eliminated from candidates[square], return\r\n  // with candidates.\r\n  if (!sudoku._in(val, candidates[square])) {\r\n    return candidates\r\n  }\r\n\r\n  // Remove `val` from candidates[square]\r\n  candidates[square] = candidates[square].replace(val, '')\r\n\r\n  // If the square has only candidate left, eliminate that value from its\r\n  // peers\r\n  let nr_candidates = candidates[square].length\r\n  if (nr_candidates === 1) {\r\n    let target_val = candidates[square]\r\n\r\n    for (let pi in SQUARE_PEERS_MAP[square]) {\r\n      let peer = SQUARE_PEERS_MAP[square][pi]\r\n\r\n      let candidates_new = sudoku._eliminate(candidates, peer, target_val)\r\n\r\n      if (!candidates_new) {\r\n        return false\r\n      }\r\n    }\r\n\r\n    // Otherwise, if the square has no candidates, we have a contradiction.\r\n    // Return false.\r\n  }\r\n  if (nr_candidates === 0) {\r\n    return false\r\n  }\r\n\r\n  // If a unit is reduced to only one place for a value, then assign it\r\n  for (let ui in SQUARE_UNITS_MAP[square]) {\r\n    let unit = SQUARE_UNITS_MAP[square][ui]\r\n\r\n    let val_places = []\r\n    for (let si in unit) {\r\n      let unit_square = unit[si]\r\n      if (sudoku._in(val, candidates[unit_square])) {\r\n        val_places.push(unit_square)\r\n      }\r\n    }\r\n\r\n    // If there's no place for this value, we have a contradition!\r\n    // return false\r\n    if (val_places.length === 0) {\r\n      return false\r\n\r\n      // Otherwise the value can only be in one place. Assign it there.\r\n    } else if (val_places.length === 1) {\r\n      let candidates_new = sudoku._assign(candidates, val_places[0], val)\r\n\r\n      if (!candidates_new) {\r\n        return false\r\n      }\r\n    }\r\n  }\r\n\r\n  return candidates\r\n}\r\n\r\n// Square relationships\r\n// -------------------------------------------------------------------------\r\n// Squares, and their relationships with values, units, and peers.\r\n\r\nsudoku._get_square_vals_map = function (board) {\r\n  /* Return a map of squares -> values\r\n   */\r\n  let squares_vals_map = {}\r\n\r\n  // Make sure `board` is a string of length 81\r\n  if (board.length != SQUARES.length) {\r\n    throw 'Board/squares length mismatch.'\r\n  } else {\r\n    for (let i in SQUARES) {\r\n      squares_vals_map[SQUARES[i]] = board[i]\r\n    }\r\n  }\r\n\r\n  return squares_vals_map\r\n}\r\n\r\nsudoku._get_square_units_map = function (squares, units) {\r\n  /* Return a map of `squares` and their associated units (row, col, box)\r\n   */\r\n  let square_unit_map = {}\r\n\r\n  // For every square...\r\n  for (let si in squares) {\r\n    let cur_square = squares[si]\r\n\r\n    // Maintain a list of the current square's units\r\n    let cur_square_units = []\r\n\r\n    // Look through the units, and see if the current square is in it,\r\n    // and if so, add it to the list of of the square's units.\r\n    for (let ui in units) {\r\n      let cur_unit = units[ui]\r\n\r\n      if (cur_unit.indexOf(cur_square) !== -1) {\r\n        cur_square_units.push(cur_unit)\r\n      }\r\n    }\r\n\r\n    // Save the current square and its units to the map\r\n    square_unit_map[cur_square] = cur_square_units\r\n  }\r\n\r\n  return square_unit_map\r\n}\r\n\r\nsudoku._get_square_peers_map = function (squares, units_map) {\r\n  /* Return a map of `squares` and their associated peers, i.e., a set of\r\n      other squares in the square's unit.\r\n      */\r\n  let square_peers_map = {}\r\n\r\n  // For every square...\r\n  for (let si in squares) {\r\n    let cur_square = squares[si]\r\n    let cur_square_units = units_map[cur_square]\r\n\r\n    // Maintain list of the current square's peers\r\n    let cur_square_peers = []\r\n\r\n    // Look through the current square's units map...\r\n    for (let sui in cur_square_units) {\r\n      let cur_unit = cur_square_units[sui]\r\n\r\n      for (let ui in cur_unit) {\r\n        let cur_unit_square = cur_unit[ui]\r\n\r\n        if (cur_square_peers.indexOf(cur_unit_square) === -1 && cur_unit_square !== cur_square) {\r\n          cur_square_peers.push(cur_unit_square)\r\n        }\r\n      }\r\n    }\r\n\r\n    // Save the current square an its associated peers to the map\r\n    square_peers_map[cur_square] = cur_square_peers\r\n  }\r\n\r\n  return square_peers_map\r\n}\r\n\r\nsudoku._get_all_units = function (rows, cols) {\r\n  /* Return a list of all units (rows, cols, boxes)\r\n   */\r\n  let units = []\r\n\r\n  // Rows\r\n  for (let ri in rows) {\r\n    units.push(sudoku._cross(rows[ri], cols))\r\n  }\r\n\r\n  // Columns\r\n  for (let ci in cols) {\r\n    units.push(sudoku._cross(rows, cols[ci]))\r\n  }\r\n\r\n  // Boxes\r\n  let row_squares = ['ABC', 'DEF', 'GHI']\r\n  let col_squares = ['123', '456', '789']\r\n  for (let rsi in row_squares) {\r\n    for (let csi in col_squares) {\r\n      units.push(sudoku._cross(row_squares[rsi], col_squares[csi]))\r\n    }\r\n  }\r\n\r\n  return units\r\n}\r\n\r\n// Conversions\r\n// -------------------------------------------------------------------------\r\nsudoku.board_string_to_grid = function (board_string) {\r\n  /* Convert a board string to a two-dimensional array\r\n   */\r\n  let rows = []\r\n  let cur_row = []\r\n  for (let i in board_string) {\r\n    cur_row.push(board_string[i])\r\n    if (i % 9 == 8) {\r\n      rows.push(cur_row)\r\n      cur_row = []\r\n    }\r\n  }\r\n  return rows\r\n}\r\n\r\nsudoku.board_grid_to_string = function (board_grid) {\r\n  /* Convert a board grid to a string\r\n   */\r\n  let board_string = ''\r\n  for (let r = 0; r < 9; ++r) {\r\n    for (let c = 0; c < 9; ++c) {\r\n      board_string += board_grid[r][c]\r\n    }\r\n  }\r\n  return board_string\r\n}\r\n\r\n// Utility\r\n// -------------------------------------------------------------------------\r\n\r\nsudoku.print_board = function (board) {\r\n  /* Print a sudoku `board` to the console.\r\n   */\r\n\r\n  // Assure a valid board\r\n  let report = sudoku.validate_board(board)\r\n  if (report !== true) {\r\n    throw report\r\n  }\r\n\r\n  let V_PADDING = ' ' // Insert after each square\r\n  let H_PADDING = '\\n' // Insert after each row\r\n\r\n  let V_BOX_PADDING = '  ' // Box vertical padding\r\n  let H_BOX_PADDING = '\\n' // Box horizontal padding\r\n\r\n  let display_string = ''\r\n\r\n  for (let i in board) {\r\n    let square = board[i]\r\n\r\n    // Add the square and some padding\r\n    display_string += square + V_PADDING\r\n\r\n    // Vertical edge of a box, insert v. box padding\r\n    if (i % 3 === 2) {\r\n      display_string += V_BOX_PADDING\r\n    }\r\n\r\n    // End of a line, insert horiz. padding\r\n    if (i % 9 === 8) {\r\n      display_string += H_PADDING\r\n    }\r\n\r\n    // Horizontal edge of a box, insert h. box padding\r\n    if (i % 27 === 26) {\r\n      display_string += H_BOX_PADDING\r\n    }\r\n  }\r\n\r\n  console.log(display_string)\r\n}\r\n\r\nsudoku.validate_board = function (board) {\r\n  /* Return if the given `board` is valid or not. If it's valid, return\r\n      true. If it's not, return a string of the reason why it's not.\r\n      */\r\n\r\n  // Check for empty board\r\n  if (!board) {\r\n    return 'Empty board'\r\n  }\r\n\r\n  // Invalid board length\r\n  if (board.length !== NR_SQUARES) {\r\n    return 'Invalid board size. Board must be exactly ' + NR_SQUARES + ' squares.'\r\n  }\r\n\r\n  // Check for invalid characters\r\n  for (let i in board) {\r\n    if (!sudoku._in(board[i], sudoku.DIGITS) && board[i] !== sudoku.BLANK_CHAR) {\r\n      return 'Invalid board character encountered at index ' + i + ': ' + board[i]\r\n    }\r\n  }\r\n\r\n  // Otherwise, we're good. Return true.\r\n  return true\r\n}\r\n\r\nsudoku._cross = function (a, b) {\r\n  /* Cross product of all elements in `a` and `b`, e.g.,\r\n      sudoku._cross(\"abc\", \"123\") ->\r\n      [\"a1\", \"a2\", \"a3\", \"b1\", \"b2\", \"b3\", \"c1\", \"c2\", \"c3\"]\r\n      */\r\n  let result = []\r\n  for (let ai in a) {\r\n    for (let bi in b) {\r\n      result.push(a[ai] + b[bi])\r\n    }\r\n  }\r\n  return result\r\n}\r\n\r\nsudoku._in = function (v, seq) {\r\n  /* Return if a value `v` is in sequence `seq`.\r\n   */\r\n  return seq.indexOf(v) !== -1\r\n}\r\n\r\nsudoku._first_true = function (seq) {\r\n  /* Return the first element in `seq` that is true. If no element is\r\n      true, return false.\r\n      */\r\n  for (let i in seq) {\r\n    if (seq[i]) {\r\n      return seq[i]\r\n    }\r\n  }\r\n  return false\r\n}\r\n\r\nsudoku._shuffle = function (seq) {\r\n  /* Return a shuffled version of `seq`\r\n   */\r\n\r\n  // Create an array of the same size as `seq` filled with false\r\n  const shuffled = []\r\n  for (let i = 0; i < seq.length; ++i) {\r\n    shuffled.push(false)\r\n  }\r\n\r\n  for (let i in seq) {\r\n    let ti = sudoku._rand_range(seq.length)\r\n\r\n    while (shuffled[ti]) {\r\n      ti = ti + 1 > seq.length - 1 ? 0 : ti + 1\r\n    }\r\n\r\n    shuffled[ti] = seq[i]\r\n  }\r\n\r\n  return shuffled\r\n}\r\n\r\nsudoku._rand_range = function (max, min) {\r\n  /* Get a random integer in the range of `min` to `max` (non inclusive).\r\n      If `min` not defined, default to 0. If `max` not defined, throw an \r\n      error.\r\n      */\r\n  min = min || 0\r\n  if (max) {\r\n    return Math.floor(Math.random() * (max - min)) + min\r\n  } else {\r\n    throw 'Range undefined'\r\n  }\r\n}\r\n\r\nsudoku._strip_dups = function (seq) {\r\n  /* Strip duplicate values from `seq`\r\n   */\r\n  let seq_set = []\r\n  let dup_map = {}\r\n  for (let i in seq) {\r\n    let e = seq[i]\r\n    if (!dup_map[e]) {\r\n      seq_set.push(e)\r\n      dup_map[e] = true\r\n    }\r\n  }\r\n  return seq_set\r\n}\r\n\r\nsudoku._force_range = function (nr, max, min) {\r\n  /* Force `nr` to be within the range from `min` to, but not including, \r\n      `max`. `min` is optional, and will default to 0. If `nr` is undefined,\r\n      treat it as zero.\r\n      */\r\n  min = min || 0\r\n  nr = nr || 0\r\n  if (nr < min) {\r\n    return min\r\n  }\r\n  if (nr > max) {\r\n    return max\r\n  }\r\n  return nr\r\n}\r\n\r\n// Initialize library after load\r\ninitialize()\r\n\r\nexport default sudoku\r\n","import sudoku from './index'\n\nconst wrapper = sudoku\nwrapper.default = sudoku\nexport default wrapper\n"],"names":["sudoku","DIGITS","COLS","SQUARES","UNITS","SQUARE_UNITS_MAP","SQUARE_PEERS_MAP","DIFFICULTY","easy","medium","hard","very-hard","insane","inhuman","BLANK_CHAR","BLANK_BOARD","generate","difficulty","unique","_force_range","NR_SQUARES","blank_board","i","candidates","_get_candidates_map","shuffled_squares","_shuffle","si","square","rand_candidate_idx","_rand_range","length","rand_candidate","_assign","single_candidates","push","_strip_dups","board","givens_idxs","nr_givens","target","parseInt","substr","solve","reverse","report","validate_board","_in","result","_search","solution","get_candidates","candidates_map","rows","cur_row","candidate_map","squares_values_map","_get_square_vals_map","val","max_nr_candidates","nr_candidates","min_nr_candidates","min_candidates_square","min_candidates","vi","candidates_copy","JSON","parse","stringify","candidates_next","other_vals","replace","ovi","other_val","_eliminate","target_val","pi","peer","ui","unit","val_places","unit_square","squares_vals_map","_get_square_units_map","squares","units","square_unit_map","cur_square","cur_square_units","cur_unit","indexOf","_get_square_peers_map","units_map","square_peers_map","cur_square_peers","sui","cur_unit_square","_get_all_units","cols","ri","_cross","ci","row_squares","col_squares","rsi","csi","board_string_to_grid","board_string","board_grid_to_string","board_grid","r","c","print_board","display_string","console","log","a","b","ai","bi","v","seq","_first_true","shuffled","ti","max","min","Math","floor","random","seq_set","dup_map","e","nr","wrapper","default"],"mappings":"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"}