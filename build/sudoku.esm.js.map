{"version":3,"file":"sudoku.esm.js","sources":["../lib/sudoku.js","../lib/index.js"],"sourcesContent":["/*\r\n    Sudoku.js\r\n    ---------\r\n    A Sudoku puzzle generator and solver JavaScript library.\r\n    Please see the README for more details.\r\n*/\r\n\r\nconst sudoku = {} // Global reference to the sudoku library\r\n\r\nsudoku.DIGITS = '123456789' // Allowed sudoku.DIGITS\r\nconst ROWS = 'ABCDEFGHI' // Row lables\r\nconst COLS = sudoku.DIGITS // Column lables\r\nlet SQUARES = null // Square IDs\r\n\r\nlet UNITS = null // All units (row, column, or box)\r\nlet SQUARE_UNITS_MAP = null // Squares -> units map\r\nlet SQUARE_PEERS_MAP = null // Squares -> peers map\r\n\r\nconst MIN_GIVENS = 17 // Minimum number of givens\r\nconst NR_SQUARES = 81 // Number of squares\r\n\r\n// Define difficulties by how many squares are given to the player in a new\r\n// puzzle.\r\nconst DIFFICULTY = {\r\n  easy: 62,\r\n  medium: 53,\r\n  hard: 44,\r\n  'very-hard': 35,\r\n  insane: 26,\r\n  inhuman: 17,\r\n}\r\n\r\n// Blank character and board representation\r\nsudoku.BLANK_CHAR = '.'\r\nsudoku.BLANK_BOARD = '....................................................' + '.............................'\r\n\r\n// Init\r\n// -------------------------------------------------------------------------\r\nfunction initialize() {\r\n  /* Initialize the Sudoku library (invoked after library load)\r\n   */\r\n  SQUARES = sudoku._cross(ROWS, COLS)\r\n  UNITS = sudoku._get_all_units(ROWS, COLS)\r\n  SQUARE_UNITS_MAP = sudoku._get_square_units_map(SQUARES, UNITS)\r\n  SQUARE_PEERS_MAP = sudoku._get_square_peers_map(SQUARES, SQUARE_UNITS_MAP)\r\n}\r\n\r\n// Generate\r\n// -------------------------------------------------------------------------\r\nsudoku.generate = function (difficulty, unique) {\r\n  /* Generate a new Sudoku puzzle of a particular `difficulty`, e.g.,\r\n      \r\n          // Generate an \"easy\" sudoku puzzle\r\n          sudoku.generate(\"easy\");\r\n          \r\n      \r\n      Difficulties are as follows, and represent the number of given squares:\r\n      \r\n              \"easy\":         61\r\n              \"medium\":       52\r\n              \"hard\":         43\r\n              \"very-hard\":    34\r\n              \"insane\":       25\r\n              \"inhuman\":      17\r\n          \r\n          \r\n      You may also enter a custom number of squares to be given, e.g.,\r\n      \r\n          // Generate a new Sudoku puzzle with 60 given squares\r\n          sudoku.generate(60)\r\n  \r\n  \r\n      `difficulty` must be a number between 17 and 81 inclusive. If it's\r\n      outside of that range, `difficulty` will be set to the closest bound,\r\n      e.g., 0 -> 17, and 100 -> 81.\r\n      \r\n      \r\n      By default, the puzzles are unique, uless you set `unique` to false. \r\n      (Note: Puzzle uniqueness is not yet implemented, so puzzles are *not* \r\n      guaranteed to have unique solutions)\r\n      \r\n      TODO: Implement puzzle uniqueness\r\n      */\r\n\r\n  // If `difficulty` is a string or undefined, convert it to a number or\r\n  // default it to \"easy\" if undefined.\r\n  if (typeof difficulty === 'string' || typeof difficulty === 'undefined') {\r\n    difficulty = DIFFICULTY[difficulty] || DIFFICULTY.easy\r\n  }\r\n\r\n  // Force difficulty between 17 and 81 inclusive\r\n  difficulty = sudoku._force_range(difficulty, NR_SQUARES + 1, MIN_GIVENS)\r\n\r\n  // Default unique to true\r\n  unique = unique || true\r\n\r\n  // Get a set of squares and all possible candidates for each square\r\n  let blank_board = ''\r\n  for (let i = 0; i < NR_SQUARES; ++i) {\r\n    blank_board += '.'\r\n  }\r\n  const candidates = sudoku._get_candidates_map(blank_board)\r\n\r\n  // For each item in a shuffled list of squares\r\n  const shuffled_squares = sudoku._shuffle(SQUARES)\r\n  for (let si in shuffled_squares) {\r\n    let square = shuffled_squares[si]\r\n\r\n    // If an assignment of a random chioce causes a contradictoin, give\r\n    // up and try again\r\n    let rand_candidate_idx = sudoku._rand_range(candidates[square].length)\r\n    let rand_candidate = candidates[square][rand_candidate_idx]\r\n    if (!sudoku._assign(candidates, square, rand_candidate)) {\r\n      break\r\n    }\r\n\r\n    // Make a list of all single candidates\r\n    let single_candidates = []\r\n    for (let si in SQUARES) {\r\n      let square = SQUARES[si]\r\n\r\n      if (candidates[square].length == 1) {\r\n        single_candidates.push(candidates[square])\r\n      }\r\n    }\r\n\r\n    // If we have at least difficulty, and the unique candidate count is\r\n    // at least 8, return the puzzle!\r\n    if (single_candidates.length >= difficulty && sudoku._strip_dups(single_candidates).length >= 8) {\r\n      let board = ''\r\n      let givens_idxs = []\r\n      for (let i in SQUARES) {\r\n        let square = SQUARES[i]\r\n        if (candidates[square].length == 1) {\r\n          board += candidates[square]\r\n          givens_idxs.push(i)\r\n        } else {\r\n          board += sudoku.BLANK_CHAR\r\n        }\r\n      }\r\n\r\n      // If we have more than `difficulty` givens, remove some random\r\n      // givens until we're down to exactly `difficulty`\r\n      let nr_givens = givens_idxs.length\r\n      if (nr_givens > difficulty) {\r\n        givens_idxs = sudoku._shuffle(givens_idxs)\r\n        for (let i = 0; i < nr_givens - difficulty; ++i) {\r\n          let target = parseInt(givens_idxs[i])\r\n          board = board.substr(0, target) + sudoku.BLANK_CHAR + board.substr(target + 1)\r\n        }\r\n      }\r\n\r\n      // Double check board is solvable\r\n      // TODO: Make a standalone board checker. Solve is expensive.\r\n      if (sudoku.solve(board)) {\r\n        return board\r\n      }\r\n    }\r\n  }\r\n\r\n  // Give up and try a new puzzle\r\n  return sudoku.generate(difficulty)\r\n}\r\n\r\n// Solve\r\n// -------------------------------------------------------------------------\r\nsudoku.solve = function (board, reverse) {\r\n  /* Solve a sudoku puzzle given a sudoku `board`, i.e., an 81-character \r\n      string of sudoku.DIGITS, 1-9, and spaces identified by '.', representing the\r\n      squares. There must be a minimum of 17 givens. If the given board has no\r\n      solutions, return false.\r\n      \r\n      Optionally set `reverse` to solve \"backwards\", i.e., rotate through the\r\n      possibilities in reverse. Useful for checking if there is more than one\r\n      solution.\r\n      */\r\n\r\n  // Assure a valid board\r\n  let report = sudoku.validate_board(board)\r\n  if (report !== true) {\r\n    throw report\r\n  }\r\n\r\n  // Check number of givens is at least MIN_GIVENS\r\n  let nr_givens = 0\r\n  for (let i in board) {\r\n    if (board[i] !== sudoku.BLANK_CHAR && sudoku._in(board[i], sudoku.DIGITS)) {\r\n      ++nr_givens\r\n    }\r\n  }\r\n  if (nr_givens < MIN_GIVENS) {\r\n    throw 'Too few givens. Minimum givens is ' + MIN_GIVENS\r\n  }\r\n\r\n  // Default reverse to false\r\n  reverse = reverse || false\r\n\r\n  let candidates = sudoku._get_candidates_map(board)\r\n  let result = sudoku._search(candidates, reverse)\r\n\r\n  if (result) {\r\n    let solution = ''\r\n    for (let square in result) {\r\n      solution += result[square]\r\n    }\r\n    return solution\r\n  }\r\n  return false\r\n}\r\n\r\nsudoku.get_candidates = function (board) {\r\n  /* Return all possible candidatees for each square as a grid of \r\n      candidates, returnning `false` if a contradiction is encountered.\r\n      \r\n      Really just a wrapper for sudoku._get_candidates_map for programmer\r\n      consumption.\r\n      */\r\n\r\n  // Assure a valid board\r\n  let report = sudoku.validate_board(board)\r\n  if (report !== true) {\r\n    throw report\r\n  }\r\n\r\n  // Get a candidates map\r\n  let candidates_map = sudoku._get_candidates_map(board)\r\n\r\n  // If there's an error, return false\r\n  if (!candidates_map) {\r\n    return false\r\n  }\r\n\r\n  // Transform candidates map into grid\r\n  let rows = []\r\n  let cur_row = []\r\n  let i = 0\r\n  for (let square in candidates_map) {\r\n    let candidates = candidates_map[square]\r\n    cur_row.push(candidates)\r\n    if (i % 9 == 8) {\r\n      rows.push(cur_row)\r\n      cur_row = []\r\n    }\r\n    ++i\r\n  }\r\n  return rows\r\n}\r\n\r\nsudoku._get_candidates_map = function (board) {\r\n  /* Get all possible candidates for each square as a map in the form\r\n      {square: sudoku.DIGITS} using recursive constraint propagation. Return `false` \r\n      if a contradiction is encountered\r\n      */\r\n\r\n  // Assure a valid board\r\n  let report = sudoku.validate_board(board)\r\n  if (report !== true) {\r\n    throw report\r\n  }\r\n\r\n  let candidate_map = {}\r\n  let squares_values_map = sudoku._get_square_vals_map(board)\r\n\r\n  // Start by assigning every digit as a candidate to every square\r\n  for (let si in SQUARES) {\r\n    candidate_map[SQUARES[si]] = sudoku.DIGITS\r\n  }\r\n\r\n  // For each non-blank square, assign its value in the candidate map and\r\n  // propigate.\r\n  for (let square in squares_values_map) {\r\n    let val = squares_values_map[square]\r\n\r\n    if (sudoku._in(val, sudoku.DIGITS)) {\r\n      let new_candidates = sudoku._assign(candidate_map, square, val)\r\n\r\n      // Fail if we can't assign val to square\r\n      if (!new_candidates) {\r\n        return false\r\n      }\r\n    }\r\n  }\r\n\r\n  return candidate_map\r\n}\r\n\r\nsudoku._search = function (candidates, reverse) {\r\n  /* Given a map of squares -> candiates, using depth-first search, \r\n      recursively try all possible values until a solution is found, or false\r\n      if no solution exists. \r\n      */\r\n\r\n  // Return if error in previous iteration\r\n  if (!candidates) {\r\n    return false\r\n  }\r\n\r\n  // Default reverse to false\r\n  reverse = reverse || false\r\n\r\n  // If only one candidate for every square, we've a solved puzzle!\r\n  // Return the candidates map.\r\n  let max_nr_candidates = 0\r\n  let max_candidates_square = null\r\n  for (let si in SQUARES) {\r\n    let square = SQUARES[si]\r\n\r\n    let nr_candidates = candidates[square].length\r\n\r\n    if (nr_candidates > max_nr_candidates) {\r\n      max_nr_candidates = nr_candidates\r\n      max_candidates_square = square\r\n    }\r\n  }\r\n  if (max_nr_candidates === 1) {\r\n    return candidates\r\n  }\r\n\r\n  // Choose the blank square with the fewest possibilities > 1\r\n  let min_nr_candidates = 10\r\n  let min_candidates_square = null\r\n  for (let si in SQUARES) {\r\n    let square = SQUARES[si]\r\n\r\n    let nr_candidates = candidates[square].length\r\n\r\n    if (nr_candidates < min_nr_candidates && nr_candidates > 1) {\r\n      min_nr_candidates = nr_candidates\r\n      min_candidates_square = square\r\n    }\r\n  }\r\n\r\n  // Recursively search through each of the candidates of the square\r\n  // starting with the one with fewest candidates.\r\n\r\n  // Rotate through the candidates forwards\r\n  let min_candidates = candidates[min_candidates_square]\r\n  if (!reverse) {\r\n    for (let vi in min_candidates) {\r\n      let val = min_candidates[vi]\r\n\r\n      // TODO: Implement a non-rediculous deep copy function\r\n      let candidates_copy = JSON.parse(JSON.stringify(candidates))\r\n      let candidates_next = sudoku._search(sudoku._assign(candidates_copy, min_candidates_square, val))\r\n\r\n      if (candidates_next) {\r\n        return candidates_next\r\n      }\r\n    }\r\n\r\n    // Rotate through the candidates backwards\r\n  } else {\r\n    for (let vi = min_candidates.length - 1; vi >= 0; --vi) {\r\n      let val = min_candidates[vi]\r\n\r\n      // TODO: Implement a non-rediculous deep copy function\r\n      let candidates_copy = JSON.parse(JSON.stringify(candidates))\r\n      let candidates_next = sudoku._search(sudoku._assign(candidates_copy, min_candidates_square, val), reverse)\r\n\r\n      if (candidates_next) {\r\n        return candidates_next\r\n      }\r\n    }\r\n  }\r\n\r\n  // If we get through all combinations of the square with the fewest\r\n  // candidates without finding an answer, there isn't one. Return false.\r\n  return false\r\n}\r\n\r\nsudoku._assign = function (candidates, square, val) {\r\n  /* Eliminate all values, *except* for `val`, from `candidates` at \r\n      `square` (candidates[square]), and propagate. Return the candidates map\r\n      when finished. If a contradiciton is found, return false.\r\n      \r\n      WARNING: This will modify the contents of `candidates` directly.\r\n      */\r\n\r\n  // Grab a list of canidates without 'val'\r\n  let other_vals = candidates[square].replace(val, '')\r\n\r\n  // Loop through all other values and eliminate them from the candidates\r\n  // at the current square, and propigate. If at any point we get a\r\n  // contradiction, return false.\r\n  for (let ovi in other_vals) {\r\n    let other_val = other_vals[ovi]\r\n\r\n    let candidates_next = sudoku._eliminate(candidates, square, other_val)\r\n\r\n    if (!candidates_next) {\r\n      //console.log(\"Contradiction found by _eliminate.\");\r\n      return false\r\n    }\r\n  }\r\n\r\n  return candidates\r\n}\r\n\r\nsudoku._eliminate = function (candidates, square, val) {\r\n  /* Eliminate `val` from `candidates` at `square`, (candidates[square]),\r\n      and propagate when values or places <= 2. Return updated candidates,\r\n      unless a contradiction is detected, in which case, return false.\r\n      \r\n      WARNING: This will modify the contents of `candidates` directly.\r\n      */\r\n\r\n  // If `val` has already been eliminated from candidates[square], return\r\n  // with candidates.\r\n  if (!sudoku._in(val, candidates[square])) {\r\n    return candidates\r\n  }\r\n\r\n  // Remove `val` from candidates[square]\r\n  candidates[square] = candidates[square].replace(val, '')\r\n\r\n  // If the square has only candidate left, eliminate that value from its\r\n  // peers\r\n  let nr_candidates = candidates[square].length\r\n  if (nr_candidates === 1) {\r\n    let target_val = candidates[square]\r\n\r\n    for (let pi in SQUARE_PEERS_MAP[square]) {\r\n      let peer = SQUARE_PEERS_MAP[square][pi]\r\n\r\n      let candidates_new = sudoku._eliminate(candidates, peer, target_val)\r\n\r\n      if (!candidates_new) {\r\n        return false\r\n      }\r\n    }\r\n\r\n    // Otherwise, if the square has no candidates, we have a contradiction.\r\n    // Return false.\r\n  }\r\n  if (nr_candidates === 0) {\r\n    return false\r\n  }\r\n\r\n  // If a unit is reduced to only one place for a value, then assign it\r\n  for (let ui in SQUARE_UNITS_MAP[square]) {\r\n    let unit = SQUARE_UNITS_MAP[square][ui]\r\n\r\n    let val_places = []\r\n    for (let si in unit) {\r\n      let unit_square = unit[si]\r\n      if (sudoku._in(val, candidates[unit_square])) {\r\n        val_places.push(unit_square)\r\n      }\r\n    }\r\n\r\n    // If there's no place for this value, we have a contradition!\r\n    // return false\r\n    if (val_places.length === 0) {\r\n      return false\r\n\r\n      // Otherwise the value can only be in one place. Assign it there.\r\n    } else if (val_places.length === 1) {\r\n      let candidates_new = sudoku._assign(candidates, val_places[0], val)\r\n\r\n      if (!candidates_new) {\r\n        return false\r\n      }\r\n    }\r\n  }\r\n\r\n  return candidates\r\n}\r\n\r\n// Square relationships\r\n// -------------------------------------------------------------------------\r\n// Squares, and their relationships with values, units, and peers.\r\n\r\nsudoku._get_square_vals_map = function (board) {\r\n  /* Return a map of squares -> values\r\n   */\r\n  let squares_vals_map = {}\r\n\r\n  // Make sure `board` is a string of length 81\r\n  if (board.length != SQUARES.length) {\r\n    throw 'Board/squares length mismatch.'\r\n  } else {\r\n    for (let i in SQUARES) {\r\n      squares_vals_map[SQUARES[i]] = board[i]\r\n    }\r\n  }\r\n\r\n  return squares_vals_map\r\n}\r\n\r\nsudoku._get_square_units_map = function (squares, units) {\r\n  /* Return a map of `squares` and their associated units (row, col, box)\r\n   */\r\n  let square_unit_map = {}\r\n\r\n  // For every square...\r\n  for (let si in squares) {\r\n    let cur_square = squares[si]\r\n\r\n    // Maintain a list of the current square's units\r\n    let cur_square_units = []\r\n\r\n    // Look through the units, and see if the current square is in it,\r\n    // and if so, add it to the list of of the square's units.\r\n    for (let ui in units) {\r\n      let cur_unit = units[ui]\r\n\r\n      if (cur_unit.indexOf(cur_square) !== -1) {\r\n        cur_square_units.push(cur_unit)\r\n      }\r\n    }\r\n\r\n    // Save the current square and its units to the map\r\n    square_unit_map[cur_square] = cur_square_units\r\n  }\r\n\r\n  return square_unit_map\r\n}\r\n\r\nsudoku._get_square_peers_map = function (squares, units_map) {\r\n  /* Return a map of `squares` and their associated peers, i.e., a set of\r\n      other squares in the square's unit.\r\n      */\r\n  let square_peers_map = {}\r\n\r\n  // For every square...\r\n  for (let si in squares) {\r\n    let cur_square = squares[si]\r\n    let cur_square_units = units_map[cur_square]\r\n\r\n    // Maintain list of the current square's peers\r\n    let cur_square_peers = []\r\n\r\n    // Look through the current square's units map...\r\n    for (let sui in cur_square_units) {\r\n      let cur_unit = cur_square_units[sui]\r\n\r\n      for (let ui in cur_unit) {\r\n        let cur_unit_square = cur_unit[ui]\r\n\r\n        if (cur_square_peers.indexOf(cur_unit_square) === -1 && cur_unit_square !== cur_square) {\r\n          cur_square_peers.push(cur_unit_square)\r\n        }\r\n      }\r\n    }\r\n\r\n    // Save the current square an its associated peers to the map\r\n    square_peers_map[cur_square] = cur_square_peers\r\n  }\r\n\r\n  return square_peers_map\r\n}\r\n\r\nsudoku._get_all_units = function (rows, cols) {\r\n  /* Return a list of all units (rows, cols, boxes)\r\n   */\r\n  let units = []\r\n\r\n  // Rows\r\n  for (let ri in rows) {\r\n    units.push(sudoku._cross(rows[ri], cols))\r\n  }\r\n\r\n  // Columns\r\n  for (let ci in cols) {\r\n    units.push(sudoku._cross(rows, cols[ci]))\r\n  }\r\n\r\n  // Boxes\r\n  let row_squares = ['ABC', 'DEF', 'GHI']\r\n  let col_squares = ['123', '456', '789']\r\n  for (let rsi in row_squares) {\r\n    for (let csi in col_squares) {\r\n      units.push(sudoku._cross(row_squares[rsi], col_squares[csi]))\r\n    }\r\n  }\r\n\r\n  return units\r\n}\r\n\r\n// Conversions\r\n// -------------------------------------------------------------------------\r\nsudoku.board_string_to_grid = function (board_string) {\r\n  /* Convert a board string to a two-dimensional array\r\n   */\r\n  let rows = []\r\n  let cur_row = []\r\n  for (let i in board_string) {\r\n    cur_row.push(board_string[i])\r\n    if (i % 9 == 8) {\r\n      rows.push(cur_row)\r\n      cur_row = []\r\n    }\r\n  }\r\n  return rows\r\n}\r\n\r\nsudoku.board_grid_to_string = function (board_grid) {\r\n  /* Convert a board grid to a string\r\n   */\r\n  let board_string = ''\r\n  for (let r = 0; r < 9; ++r) {\r\n    for (let c = 0; c < 9; ++c) {\r\n      board_string += board_grid[r][c]\r\n    }\r\n  }\r\n  return board_string\r\n}\r\n\r\n// Utility\r\n// -------------------------------------------------------------------------\r\n\r\nsudoku.print_board = function (board) {\r\n  /* Print a sudoku `board` to the console.\r\n   */\r\n\r\n  // Assure a valid board\r\n  let report = sudoku.validate_board(board)\r\n  if (report !== true) {\r\n    throw report\r\n  }\r\n\r\n  let V_PADDING = ' ' // Insert after each square\r\n  let H_PADDING = '\\n' // Insert after each row\r\n\r\n  let V_BOX_PADDING = '  ' // Box vertical padding\r\n  let H_BOX_PADDING = '\\n' // Box horizontal padding\r\n\r\n  let display_string = ''\r\n\r\n  for (let i in board) {\r\n    let square = board[i]\r\n\r\n    // Add the square and some padding\r\n    display_string += square + V_PADDING\r\n\r\n    // Vertical edge of a box, insert v. box padding\r\n    if (i % 3 === 2) {\r\n      display_string += V_BOX_PADDING\r\n    }\r\n\r\n    // End of a line, insert horiz. padding\r\n    if (i % 9 === 8) {\r\n      display_string += H_PADDING\r\n    }\r\n\r\n    // Horizontal edge of a box, insert h. box padding\r\n    if (i % 27 === 26) {\r\n      display_string += H_BOX_PADDING\r\n    }\r\n  }\r\n\r\n  console.log(display_string)\r\n}\r\n\r\nsudoku.validate_board = function (board) {\r\n  /* Return if the given `board` is valid or not. If it's valid, return\r\n      true. If it's not, return a string of the reason why it's not.\r\n      */\r\n\r\n  // Check for empty board\r\n  if (!board) {\r\n    return 'Empty board'\r\n  }\r\n\r\n  // Invalid board length\r\n  if (board.length !== NR_SQUARES) {\r\n    return 'Invalid board size. Board must be exactly ' + NR_SQUARES + ' squares.'\r\n  }\r\n\r\n  // Check for invalid characters\r\n  for (let i in board) {\r\n    if (!sudoku._in(board[i], sudoku.DIGITS) && board[i] !== sudoku.BLANK_CHAR) {\r\n      return 'Invalid board character encountered at index ' + i + ': ' + board[i]\r\n    }\r\n  }\r\n\r\n  // Otherwise, we're good. Return true.\r\n  return true\r\n}\r\n\r\nsudoku._cross = function (a, b) {\r\n  /* Cross product of all elements in `a` and `b`, e.g.,\r\n      sudoku._cross(\"abc\", \"123\") ->\r\n      [\"a1\", \"a2\", \"a3\", \"b1\", \"b2\", \"b3\", \"c1\", \"c2\", \"c3\"]\r\n      */\r\n  let result = []\r\n  for (let ai in a) {\r\n    for (let bi in b) {\r\n      result.push(a[ai] + b[bi])\r\n    }\r\n  }\r\n  return result\r\n}\r\n\r\nsudoku._in = function (v, seq) {\r\n  /* Return if a value `v` is in sequence `seq`.\r\n   */\r\n  return seq.indexOf(v) !== -1\r\n}\r\n\r\nsudoku._first_true = function (seq) {\r\n  /* Return the first element in `seq` that is true. If no element is\r\n      true, return false.\r\n      */\r\n  for (let i in seq) {\r\n    if (seq[i]) {\r\n      return seq[i]\r\n    }\r\n  }\r\n  return false\r\n}\r\n\r\nsudoku._shuffle = function (seq) {\r\n  /* Return a shuffled version of `seq`\r\n   */\r\n\r\n  // Create an array of the same size as `seq` filled with false\r\n  const shuffled = []\r\n  for (let i = 0; i < seq.length; ++i) {\r\n    shuffled.push(false)\r\n  }\r\n\r\n  for (let i in seq) {\r\n    let ti = sudoku._rand_range(seq.length)\r\n\r\n    while (shuffled[ti]) {\r\n      ti = ti + 1 > seq.length - 1 ? 0 : ti + 1\r\n    }\r\n\r\n    shuffled[ti] = seq[i]\r\n  }\r\n\r\n  return shuffled\r\n}\r\n\r\nsudoku._rand_range = function (max, min) {\r\n  /* Get a random integer in the range of `min` to `max` (non inclusive).\r\n      If `min` not defined, default to 0. If `max` not defined, throw an \r\n      error.\r\n      */\r\n  min = min || 0\r\n  if (max) {\r\n    return Math.floor(Math.random() * (max - min)) + min\r\n  } else {\r\n    throw 'Range undefined'\r\n  }\r\n}\r\n\r\nsudoku._strip_dups = function (seq) {\r\n  /* Strip duplicate values from `seq`\r\n   */\r\n  let seq_set = []\r\n  let dup_map = {}\r\n  for (let i in seq) {\r\n    let e = seq[i]\r\n    if (!dup_map[e]) {\r\n      seq_set.push(e)\r\n      dup_map[e] = true\r\n    }\r\n  }\r\n  return seq_set\r\n}\r\n\r\nsudoku._force_range = function (nr, max, min) {\r\n  /* Force `nr` to be within the range from `min` to, but not including, \r\n      `max`. `min` is optional, and will default to 0. If `nr` is undefined,\r\n      treat it as zero.\r\n      */\r\n  min = min || 0\r\n  nr = nr || 0\r\n  if (nr < min) {\r\n    return min\r\n  }\r\n  if (nr > max) {\r\n    return max\r\n  }\r\n  return nr\r\n}\r\n\r\n// Initialize library after load\r\ninitialize()\r\n\r\nexport default sudoku\r\n","'use strict'\n\nimport sudoku from './sudoku'\n\nexport function generate(difficulty, unique) {\n  return sudoku.generate(difficulty, unique)\n}\n\nexport function solve(board, reverse) {\n  return sudoku.solve(board, reverse)\n}\n\nexport function get_candidates(board) {\n  return sudoku.get_candidates(board)\n}\n\nexport function board_string_to_grid(board_string) {\n  return sudoku.board_string_to_grid(board_string)\n}\n\nexport function print_board(board) {\n  return sudoku.print_board(board)\n}\n\nexport function validate_board(board) {\n  return sudoku.validate_board(board)\n}\n\nexport default sudoku\n"],"names":["sudoku","DIGITS","COLS","SQUARES","UNITS","SQUARE_UNITS_MAP","SQUARE_PEERS_MAP","DIFFICULTY","easy","medium","hard","very-hard","insane","inhuman","generate","difficulty","unique","solve","board","reverse","get_candidates","board_string_to_grid","board_string","print_board","validate_board","BLANK_CHAR","BLANK_BOARD","_force_range","NR_SQUARES","blank_board","i","candidates","_get_candidates_map","shuffled_squares","_shuffle","si","square","rand_candidate_idx","_rand_range","length","rand_candidate","_assign","single_candidates","push","_strip_dups","givens_idxs","nr_givens","target","parseInt","substr","report","_in","result","_search","solution","candidates_map","rows","cur_row","candidate_map","squares_values_map","_get_square_vals_map","val","max_nr_candidates","nr_candidates","min_nr_candidates","min_candidates_square","min_candidates","vi","candidates_copy","JSON","parse","stringify","candidates_next","other_vals","replace","ovi","other_val","_eliminate","target_val","pi","peer","ui","unit","val_places","unit_square","squares_vals_map","_get_square_units_map","squares","units","square_unit_map","cur_square","cur_square_units","cur_unit","indexOf","_get_square_peers_map","units_map","square_peers_map","cur_square_peers","sui","cur_unit_square","_get_all_units","cols","ri","_cross","ci","row_squares","col_squares","rsi","csi","board_grid_to_string","board_grid","r","c","display_string","console","log","a","b","ai","bi","v","seq","_first_true","shuffled","ti","max","min","Math","floor","random","seq_set","dup_map","e","nr"],"mappings":"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"}