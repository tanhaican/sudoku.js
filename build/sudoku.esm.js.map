{"version":3,"file":"sudoku.esm.js","sources":["../lib/sudoku.js","../lib/index.js"],"sourcesContent":["/*\r\n    Sudoku.js\r\n    ---------\r\n    A Sudoku puzzle generator and solver JavaScript library.\r\n    Please see the README for more details.\r\n*/\r\n\r\nconst sudoku = {} // Global reference to the sudoku library\r\n\r\nsudoku.DIGITS = '123456789' // Allowed sudoku.DIGITS\r\nconst ROWS = 'ABCDEFGHI' // Row lables\r\nconst COLS = sudoku.DIGITS // Column lables\r\nlet SQUARES = null // Square IDs\r\n\r\nlet UNITS = null // All units (row, column, or box)\r\nlet SQUARE_UNITS_MAP = null // Squares -> units map\r\nlet SQUARE_PEERS_MAP = null // Squares -> peers map\r\n\r\nconst MIN_GIVENS = 17 // Minimum number of givens\r\nconst NR_SQUARES = 81 // Number of squares\r\n\r\n// Define difficulties by how many squares are given to the player in a new\r\n// puzzle.\r\nconst DIFFICULTY = {\r\n  easy: 62,\r\n  medium: 53,\r\n  hard: 44,\r\n  'very-hard': 35,\r\n  insane: 26,\r\n  inhuman: 17,\r\n}\r\n\r\n// Blank character and board representation\r\nsudoku.BLANK_CHAR = '.'\r\nsudoku.BLANK_BOARD = '....................................................' + '.............................'\r\n\r\n// Init\r\n// -------------------------------------------------------------------------\r\nfunction initialize() {\r\n  /* Initialize the Sudoku library (invoked after library load)\r\n   */\r\n  SQUARES = sudoku._cross(ROWS, COLS)\r\n  UNITS = sudoku._get_all_units(ROWS, COLS)\r\n  SQUARE_UNITS_MAP = sudoku._get_square_units_map(SQUARES, UNITS)\r\n  SQUARE_PEERS_MAP = sudoku._get_square_peers_map(SQUARES, SQUARE_UNITS_MAP)\r\n}\r\n\r\n// Generate\r\n// -------------------------------------------------------------------------\r\nsudoku.generate = function (difficulty, unique) {\r\n  /* Generate a new Sudoku puzzle of a particular `difficulty`, e.g.,\r\n      \r\n          // Generate an \"easy\" sudoku puzzle\r\n          sudoku.generate(\"easy\");\r\n          \r\n      \r\n      Difficulties are as follows, and represent the number of given squares:\r\n      \r\n              \"easy\":         61\r\n              \"medium\":       52\r\n              \"hard\":         43\r\n              \"very-hard\":    34\r\n              \"insane\":       25\r\n              \"inhuman\":      17\r\n          \r\n          \r\n      You may also enter a custom number of squares to be given, e.g.,\r\n      \r\n          // Generate a new Sudoku puzzle with 60 given squares\r\n          sudoku.generate(60)\r\n  \r\n  \r\n      `difficulty` must be a number between 17 and 81 inclusive. If it's\r\n      outside of that range, `difficulty` will be set to the closest bound,\r\n      e.g., 0 -> 17, and 100 -> 81.\r\n      \r\n      \r\n      By default, the puzzles are unique, uless you set `unique` to false. \r\n      (Note: Puzzle uniqueness is not yet implemented, so puzzles are *not* \r\n      guaranteed to have unique solutions)\r\n      \r\n      TODO: Implement puzzle uniqueness\r\n      */\r\n\r\n  // If `difficulty` is a string or undefined, convert it to a number or\r\n  // default it to \"easy\" if undefined.\r\n  if (typeof difficulty === 'string' || typeof difficulty === 'undefined') {\r\n    difficulty = DIFFICULTY[difficulty] || DIFFICULTY.easy\r\n  }\r\n\r\n  // Force difficulty between 17 and 81 inclusive\r\n  difficulty = sudoku._force_range(difficulty, NR_SQUARES + 1, MIN_GIVENS)\r\n\r\n  // Default unique to true\r\n  unique = unique || true\r\n\r\n  // Get a set of squares and all possible candidates for each square\r\n  let blank_board = ''\r\n  for (let i = 0; i < NR_SQUARES; ++i) {\r\n    blank_board += '.'\r\n  }\r\n  const candidates = sudoku._get_candidates_map(blank_board)\r\n\r\n  // For each item in a shuffled list of squares\r\n  const shuffled_squares = sudoku._shuffle(SQUARES)\r\n  for (let si in shuffled_squares) {\r\n    let square = shuffled_squares[si]\r\n\r\n    // If an assignment of a random chioce causes a contradictoin, give\r\n    // up and try again\r\n    let rand_candidate_idx = sudoku._rand_range(candidates[square].length)\r\n    let rand_candidate = candidates[square][rand_candidate_idx]\r\n    if (!sudoku._assign(candidates, square, rand_candidate)) {\r\n      break\r\n    }\r\n\r\n    // Make a list of all single candidates\r\n    let single_candidates = []\r\n    for (let si in SQUARES) {\r\n      let square = SQUARES[si]\r\n\r\n      if (candidates[square].length == 1) {\r\n        single_candidates.push(candidates[square])\r\n      }\r\n    }\r\n\r\n    // If we have at least difficulty, and the unique candidate count is\r\n    // at least 8, return the puzzle!\r\n    if (single_candidates.length >= difficulty && sudoku._strip_dups(single_candidates).length >= 8) {\r\n      let board = ''\r\n      let givens_idxs = []\r\n      for (let i in SQUARES) {\r\n        let square = SQUARES[i]\r\n        if (candidates[square].length == 1) {\r\n          board += candidates[square]\r\n          givens_idxs.push(i)\r\n        } else {\r\n          board += sudoku.BLANK_CHAR\r\n        }\r\n      }\r\n\r\n      // If we have more than `difficulty` givens, remove some random\r\n      // givens until we're down to exactly `difficulty`\r\n      let nr_givens = givens_idxs.length\r\n      if (nr_givens > difficulty) {\r\n        givens_idxs = sudoku._shuffle(givens_idxs)\r\n        for (let i = 0; i < nr_givens - difficulty; ++i) {\r\n          let target = parseInt(givens_idxs[i])\r\n          board = board.substr(0, target) + sudoku.BLANK_CHAR + board.substr(target + 1)\r\n        }\r\n      }\r\n\r\n      // Double check board is solvable\r\n      // TODO: Make a standalone board checker. Solve is expensive.\r\n      if (sudoku.solve(board)) {\r\n        return board\r\n      }\r\n    }\r\n  }\r\n\r\n  // Give up and try a new puzzle\r\n  return sudoku.generate(difficulty)\r\n}\r\n\r\n// Solve\r\n// -------------------------------------------------------------------------\r\nsudoku.solve = function (board, reverse) {\r\n  /* Solve a sudoku puzzle given a sudoku `board`, i.e., an 81-character \r\n      string of sudoku.DIGITS, 1-9, and spaces identified by '.', representing the\r\n      squares. There must be a minimum of 17 givens. If the given board has no\r\n      solutions, return false.\r\n      \r\n      Optionally set `reverse` to solve \"backwards\", i.e., rotate through the\r\n      possibilities in reverse. Useful for checking if there is more than one\r\n      solution.\r\n      */\r\n\r\n  // Assure a valid board\r\n  let report = sudoku.validate_board(board)\r\n  if (report !== true) {\r\n    throw report\r\n  }\r\n\r\n  // Check number of givens is at least MIN_GIVENS\r\n  let nr_givens = 0\r\n  for (let i in board) {\r\n    if (board[i] !== sudoku.BLANK_CHAR && sudoku._in(board[i], sudoku.DIGITS)) {\r\n      ++nr_givens\r\n    }\r\n  }\r\n  if (nr_givens < MIN_GIVENS) {\r\n    throw 'Too few givens. Minimum givens is ' + MIN_GIVENS\r\n  }\r\n\r\n  // Default reverse to false\r\n  reverse = reverse || false\r\n\r\n  let candidates = sudoku._get_candidates_map(board)\r\n  let result = sudoku._search(candidates, reverse)\r\n\r\n  if (result) {\r\n    let solution = ''\r\n    for (let square in result) {\r\n      solution += result[square]\r\n    }\r\n    return solution\r\n  }\r\n  return false\r\n}\r\n\r\nsudoku.get_candidates = function (board) {\r\n  /* Return all possible candidatees for each square as a grid of \r\n      candidates, returnning `false` if a contradiction is encountered.\r\n      \r\n      Really just a wrapper for sudoku._get_candidates_map for programmer\r\n      consumption.\r\n      */\r\n\r\n  // Assure a valid board\r\n  let report = sudoku.validate_board(board)\r\n  if (report !== true) {\r\n    throw report\r\n  }\r\n\r\n  // Get a candidates map\r\n  let candidates_map = sudoku._get_candidates_map(board)\r\n\r\n  // If there's an error, return false\r\n  if (!candidates_map) {\r\n    return false\r\n  }\r\n\r\n  // Transform candidates map into grid\r\n  let rows = []\r\n  let cur_row = []\r\n  let i = 0\r\n  for (let square in candidates_map) {\r\n    let candidates = candidates_map[square]\r\n    cur_row.push(candidates)\r\n    if (i % 9 == 8) {\r\n      rows.push(cur_row)\r\n      cur_row = []\r\n    }\r\n    ++i\r\n  }\r\n  return rows\r\n}\r\n\r\nsudoku._get_candidates_map = function (board) {\r\n  /* Get all possible candidates for each square as a map in the form\r\n      {square: sudoku.DIGITS} using recursive constraint propagation. Return `false` \r\n      if a contradiction is encountered\r\n      */\r\n\r\n  // Assure a valid board\r\n  let report = sudoku.validate_board(board)\r\n  if (report !== true) {\r\n    throw report\r\n  }\r\n\r\n  let candidate_map = {}\r\n  let squares_values_map = sudoku._get_square_vals_map(board)\r\n\r\n  // Start by assigning every digit as a candidate to every square\r\n  for (let si in SQUARES) {\r\n    candidate_map[SQUARES[si]] = sudoku.DIGITS\r\n  }\r\n\r\n  // For each non-blank square, assign its value in the candidate map and\r\n  // propigate.\r\n  for (let square in squares_values_map) {\r\n    let val = squares_values_map[square]\r\n\r\n    if (sudoku._in(val, sudoku.DIGITS)) {\r\n      let new_candidates = sudoku._assign(candidate_map, square, val)\r\n\r\n      // Fail if we can't assign val to square\r\n      if (!new_candidates) {\r\n        return false\r\n      }\r\n    }\r\n  }\r\n\r\n  return candidate_map\r\n}\r\n\r\nsudoku._search = function (candidates, reverse) {\r\n  /* Given a map of squares -> candiates, using depth-first search, \r\n      recursively try all possible values until a solution is found, or false\r\n      if no solution exists. \r\n      */\r\n\r\n  // Return if error in previous iteration\r\n  if (!candidates) {\r\n    return false\r\n  }\r\n\r\n  // Default reverse to false\r\n  reverse = reverse || false\r\n\r\n  // If only one candidate for every square, we've a solved puzzle!\r\n  // Return the candidates map.\r\n  let max_nr_candidates = 0\r\n  let max_candidates_square = null\r\n  for (let si in SQUARES) {\r\n    let square = SQUARES[si]\r\n\r\n    let nr_candidates = candidates[square].length\r\n\r\n    if (nr_candidates > max_nr_candidates) {\r\n      max_nr_candidates = nr_candidates\r\n      max_candidates_square = square\r\n    }\r\n  }\r\n  if (max_nr_candidates === 1) {\r\n    return candidates\r\n  }\r\n\r\n  // Choose the blank square with the fewest possibilities > 1\r\n  let min_nr_candidates = 10\r\n  let min_candidates_square = null\r\n  for (let si in SQUARES) {\r\n    let square = SQUARES[si]\r\n\r\n    let nr_candidates = candidates[square].length\r\n\r\n    if (nr_candidates < min_nr_candidates && nr_candidates > 1) {\r\n      min_nr_candidates = nr_candidates\r\n      min_candidates_square = square\r\n    }\r\n  }\r\n\r\n  // Recursively search through each of the candidates of the square\r\n  // starting with the one with fewest candidates.\r\n\r\n  // Rotate through the candidates forwards\r\n  let min_candidates = candidates[min_candidates_square]\r\n  if (!reverse) {\r\n    for (let vi in min_candidates) {\r\n      let val = min_candidates[vi]\r\n\r\n      // TODO: Implement a non-rediculous deep copy function\r\n      let candidates_copy = JSON.parse(JSON.stringify(candidates))\r\n      let candidates_next = sudoku._search(sudoku._assign(candidates_copy, min_candidates_square, val))\r\n\r\n      if (candidates_next) {\r\n        return candidates_next\r\n      }\r\n    }\r\n\r\n    // Rotate through the candidates backwards\r\n  } else {\r\n    for (let vi = min_candidates.length - 1; vi >= 0; --vi) {\r\n      let val = min_candidates[vi]\r\n\r\n      // TODO: Implement a non-rediculous deep copy function\r\n      let candidates_copy = JSON.parse(JSON.stringify(candidates))\r\n      let candidates_next = sudoku._search(sudoku._assign(candidates_copy, min_candidates_square, val), reverse)\r\n\r\n      if (candidates_next) {\r\n        return candidates_next\r\n      }\r\n    }\r\n  }\r\n\r\n  // If we get through all combinations of the square with the fewest\r\n  // candidates without finding an answer, there isn't one. Return false.\r\n  return false\r\n}\r\n\r\nsudoku._assign = function (candidates, square, val) {\r\n  /* Eliminate all values, *except* for `val`, from `candidates` at \r\n      `square` (candidates[square]), and propagate. Return the candidates map\r\n      when finished. If a contradiciton is found, return false.\r\n      \r\n      WARNING: This will modify the contents of `candidates` directly.\r\n      */\r\n\r\n  // Grab a list of canidates without 'val'\r\n  let other_vals = candidates[square].replace(val, '')\r\n\r\n  // Loop through all other values and eliminate them from the candidates\r\n  // at the current square, and propigate. If at any point we get a\r\n  // contradiction, return false.\r\n  for (let ovi in other_vals) {\r\n    let other_val = other_vals[ovi]\r\n\r\n    let candidates_next = sudoku._eliminate(candidates, square, other_val)\r\n\r\n    if (!candidates_next) {\r\n      //console.log(\"Contradiction found by _eliminate.\");\r\n      return false\r\n    }\r\n  }\r\n\r\n  return candidates\r\n}\r\n\r\nsudoku._eliminate = function (candidates, square, val) {\r\n  /* Eliminate `val` from `candidates` at `square`, (candidates[square]),\r\n      and propagate when values or places <= 2. Return updated candidates,\r\n      unless a contradiction is detected, in which case, return false.\r\n      \r\n      WARNING: This will modify the contents of `candidates` directly.\r\n      */\r\n\r\n  // If `val` has already been eliminated from candidates[square], return\r\n  // with candidates.\r\n  if (!sudoku._in(val, candidates[square])) {\r\n    return candidates\r\n  }\r\n\r\n  // Remove `val` from candidates[square]\r\n  candidates[square] = candidates[square].replace(val, '')\r\n\r\n  // If the square has only candidate left, eliminate that value from its\r\n  // peers\r\n  let nr_candidates = candidates[square].length\r\n  if (nr_candidates === 1) {\r\n    let target_val = candidates[square]\r\n\r\n    for (let pi in SQUARE_PEERS_MAP[square]) {\r\n      let peer = SQUARE_PEERS_MAP[square][pi]\r\n\r\n      let candidates_new = sudoku._eliminate(candidates, peer, target_val)\r\n\r\n      if (!candidates_new) {\r\n        return false\r\n      }\r\n    }\r\n\r\n    // Otherwise, if the square has no candidates, we have a contradiction.\r\n    // Return false.\r\n  }\r\n  if (nr_candidates === 0) {\r\n    return false\r\n  }\r\n\r\n  // If a unit is reduced to only one place for a value, then assign it\r\n  for (let ui in SQUARE_UNITS_MAP[square]) {\r\n    let unit = SQUARE_UNITS_MAP[square][ui]\r\n\r\n    let val_places = []\r\n    for (let si in unit) {\r\n      let unit_square = unit[si]\r\n      if (sudoku._in(val, candidates[unit_square])) {\r\n        val_places.push(unit_square)\r\n      }\r\n    }\r\n\r\n    // If there's no place for this value, we have a contradition!\r\n    // return false\r\n    if (val_places.length === 0) {\r\n      return false\r\n\r\n      // Otherwise the value can only be in one place. Assign it there.\r\n    } else if (val_places.length === 1) {\r\n      let candidates_new = sudoku._assign(candidates, val_places[0], val)\r\n\r\n      if (!candidates_new) {\r\n        return false\r\n      }\r\n    }\r\n  }\r\n\r\n  return candidates\r\n}\r\n\r\n// Square relationships\r\n// -------------------------------------------------------------------------\r\n// Squares, and their relationships with values, units, and peers.\r\n\r\nsudoku._get_square_vals_map = function (board) {\r\n  /* Return a map of squares -> values\r\n   */\r\n  let squares_vals_map = {}\r\n\r\n  // Make sure `board` is a string of length 81\r\n  if (board.length != SQUARES.length) {\r\n    throw 'Board/squares length mismatch.'\r\n  } else {\r\n    for (let i in SQUARES) {\r\n      squares_vals_map[SQUARES[i]] = board[i]\r\n    }\r\n  }\r\n\r\n  return squares_vals_map\r\n}\r\n\r\nsudoku._get_square_units_map = function (squares, units) {\r\n  /* Return a map of `squares` and their associated units (row, col, box)\r\n   */\r\n  let square_unit_map = {}\r\n\r\n  // For every square...\r\n  for (let si in squares) {\r\n    let cur_square = squares[si]\r\n\r\n    // Maintain a list of the current square's units\r\n    let cur_square_units = []\r\n\r\n    // Look through the units, and see if the current square is in it,\r\n    // and if so, add it to the list of of the square's units.\r\n    for (let ui in units) {\r\n      let cur_unit = units[ui]\r\n\r\n      if (cur_unit.indexOf(cur_square) !== -1) {\r\n        cur_square_units.push(cur_unit)\r\n      }\r\n    }\r\n\r\n    // Save the current square and its units to the map\r\n    square_unit_map[cur_square] = cur_square_units\r\n  }\r\n\r\n  return square_unit_map\r\n}\r\n\r\nsudoku._get_square_peers_map = function (squares, units_map) {\r\n  /* Return a map of `squares` and their associated peers, i.e., a set of\r\n      other squares in the square's unit.\r\n      */\r\n  let square_peers_map = {}\r\n\r\n  // For every square...\r\n  for (let si in squares) {\r\n    let cur_square = squares[si]\r\n    let cur_square_units = units_map[cur_square]\r\n\r\n    // Maintain list of the current square's peers\r\n    let cur_square_peers = []\r\n\r\n    // Look through the current square's units map...\r\n    for (let sui in cur_square_units) {\r\n      let cur_unit = cur_square_units[sui]\r\n\r\n      for (let ui in cur_unit) {\r\n        let cur_unit_square = cur_unit[ui]\r\n\r\n        if (cur_square_peers.indexOf(cur_unit_square) === -1 && cur_unit_square !== cur_square) {\r\n          cur_square_peers.push(cur_unit_square)\r\n        }\r\n      }\r\n    }\r\n\r\n    // Save the current square an its associated peers to the map\r\n    square_peers_map[cur_square] = cur_square_peers\r\n  }\r\n\r\n  return square_peers_map\r\n}\r\n\r\nsudoku._get_all_units = function (rows, cols) {\r\n  /* Return a list of all units (rows, cols, boxes)\r\n   */\r\n  let units = []\r\n\r\n  // Rows\r\n  for (let ri in rows) {\r\n    units.push(sudoku._cross(rows[ri], cols))\r\n  }\r\n\r\n  // Columns\r\n  for (let ci in cols) {\r\n    units.push(sudoku._cross(rows, cols[ci]))\r\n  }\r\n\r\n  // Boxes\r\n  let row_squares = ['ABC', 'DEF', 'GHI']\r\n  let col_squares = ['123', '456', '789']\r\n  for (let rsi in row_squares) {\r\n    for (let csi in col_squares) {\r\n      units.push(sudoku._cross(row_squares[rsi], col_squares[csi]))\r\n    }\r\n  }\r\n\r\n  return units\r\n}\r\n\r\n// Conversions\r\n// -------------------------------------------------------------------------\r\nsudoku.board_string_to_grid = function (board_string) {\r\n  /* Convert a board string to a two-dimensional array\r\n   */\r\n  let rows = []\r\n  let cur_row = []\r\n  for (let i in board_string) {\r\n    cur_row.push(board_string[i])\r\n    if (i % 9 == 8) {\r\n      rows.push(cur_row)\r\n      cur_row = []\r\n    }\r\n  }\r\n  return rows\r\n}\r\n\r\nsudoku.board_grid_to_string = function (board_grid) {\r\n  /* Convert a board grid to a string\r\n   */\r\n  let board_string = ''\r\n  for (let r = 0; r < 9; ++r) {\r\n    for (let c = 0; c < 9; ++c) {\r\n      board_string += board_grid[r][c]\r\n    }\r\n  }\r\n  return board_string\r\n}\r\n\r\n// Utility\r\n// -------------------------------------------------------------------------\r\n\r\nsudoku.print_board = function (board) {\r\n  /* Print a sudoku `board` to the console.\r\n   */\r\n\r\n  // Assure a valid board\r\n  let report = sudoku.validate_board(board)\r\n  if (report !== true) {\r\n    throw report\r\n  }\r\n\r\n  let V_PADDING = ' ' // Insert after each square\r\n  let H_PADDING = '\\n' // Insert after each row\r\n\r\n  let V_BOX_PADDING = '  ' // Box vertical padding\r\n  let H_BOX_PADDING = '\\n' // Box horizontal padding\r\n\r\n  let display_string = ''\r\n\r\n  for (let i in board) {\r\n    let square = board[i]\r\n\r\n    // Add the square and some padding\r\n    display_string += square + V_PADDING\r\n\r\n    // Vertical edge of a box, insert v. box padding\r\n    if (i % 3 === 2) {\r\n      display_string += V_BOX_PADDING\r\n    }\r\n\r\n    // End of a line, insert horiz. padding\r\n    if (i % 9 === 8) {\r\n      display_string += H_PADDING\r\n    }\r\n\r\n    // Horizontal edge of a box, insert h. box padding\r\n    if (i % 27 === 26) {\r\n      display_string += H_BOX_PADDING\r\n    }\r\n  }\r\n\r\n  console.log(display_string)\r\n}\r\n\r\nsudoku.validate_board = function (board) {\r\n  /* Return if the given `board` is valid or not. If it's valid, return\r\n      true. If it's not, return a string of the reason why it's not.\r\n      */\r\n\r\n  // Check for empty board\r\n  if (!board) {\r\n    return 'Empty board'\r\n  }\r\n\r\n  // Invalid board length\r\n  if (board.length !== NR_SQUARES) {\r\n    return 'Invalid board size. Board must be exactly ' + NR_SQUARES + ' squares.'\r\n  }\r\n\r\n  // Check for invalid characters\r\n  for (let i in board) {\r\n    if (!sudoku._in(board[i], sudoku.DIGITS) && board[i] !== sudoku.BLANK_CHAR) {\r\n      return 'Invalid board character encountered at index ' + i + ': ' + board[i]\r\n    }\r\n  }\r\n\r\n  // Otherwise, we're good. Return true.\r\n  return true\r\n}\r\n\r\nsudoku._cross = function (a, b) {\r\n  /* Cross product of all elements in `a` and `b`, e.g.,\r\n      sudoku._cross(\"abc\", \"123\") ->\r\n      [\"a1\", \"a2\", \"a3\", \"b1\", \"b2\", \"b3\", \"c1\", \"c2\", \"c3\"]\r\n      */\r\n  let result = []\r\n  for (let ai in a) {\r\n    for (let bi in b) {\r\n      result.push(a[ai] + b[bi])\r\n    }\r\n  }\r\n  return result\r\n}\r\n\r\nsudoku._in = function (v, seq) {\r\n  /* Return if a value `v` is in sequence `seq`.\r\n   */\r\n  return seq.indexOf(v) !== -1\r\n}\r\n\r\nsudoku._first_true = function (seq) {\r\n  /* Return the first element in `seq` that is true. If no element is\r\n      true, return false.\r\n      */\r\n  for (let i in seq) {\r\n    if (seq[i]) {\r\n      return seq[i]\r\n    }\r\n  }\r\n  return false\r\n}\r\n\r\nsudoku._shuffle = function (seq) {\r\n  /* Return a shuffled version of `seq`\r\n   */\r\n\r\n  // Create an array of the same size as `seq` filled with false\r\n  const shuffled = []\r\n  for (let i = 0; i < seq.length; ++i) {\r\n    shuffled.push(false)\r\n  }\r\n\r\n  for (let i in seq) {\r\n    let ti = sudoku._rand_range(seq.length)\r\n\r\n    while (shuffled[ti]) {\r\n      ti = ti + 1 > seq.length - 1 ? 0 : ti + 1\r\n    }\r\n\r\n    shuffled[ti] = seq[i]\r\n  }\r\n\r\n  return shuffled\r\n}\r\n\r\nsudoku._rand_range = function (max, min) {\r\n  /* Get a random integer in the range of `min` to `max` (non inclusive).\r\n      If `min` not defined, default to 0. If `max` not defined, throw an \r\n      error.\r\n      */\r\n  min = min || 0\r\n  if (max) {\r\n    return Math.floor(Math.random() * (max - min)) + min\r\n  } else {\r\n    throw 'Range undefined'\r\n  }\r\n}\r\n\r\nsudoku._strip_dups = function (seq) {\r\n  /* Strip duplicate values from `seq`\r\n   */\r\n  let seq_set = []\r\n  let dup_map = {}\r\n  for (let i in seq) {\r\n    let e = seq[i]\r\n    if (!dup_map[e]) {\r\n      seq_set.push(e)\r\n      dup_map[e] = true\r\n    }\r\n  }\r\n  return seq_set\r\n}\r\n\r\nsudoku._force_range = function (nr, max, min) {\r\n  /* Force `nr` to be within the range from `min` to, but not including, \r\n      `max`. `min` is optional, and will default to 0. If `nr` is undefined,\r\n      treat it as zero.\r\n      */\r\n  min = min || 0\r\n  nr = nr || 0\r\n  if (nr < min) {\r\n    return min\r\n  }\r\n  if (nr > max) {\r\n    return max\r\n  }\r\n  return nr\r\n}\r\n\r\n// Initialize library after load\r\ninitialize()\r\n\r\nexport default sudoku\r\n","'use strict'\n\nimport sudoku from './sudoku'\n\nexport function generate(difficulty, unique) {\n  return sudoku.generate(difficulty, unique)\n}\n\nexport function solve(board, reverse) {\n  return sudoku.solve(board, reverse)\n}\n\nexport function get_candidates(board) {\n  return sudoku.get_candidates(board)\n}\n\nexport function board_string_to_grid(board_string) {\n  return sudoku.board_string_to_grid(board_string)\n}\n\nexport function print_board(board) {\n  return sudoku.print_board(board)\n}\n\nexport function validate_board(board) {\n  return sudoku.validate_board(board)\n}\n\nexport default sudoku\n"],"names":[],"mappings":"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"}